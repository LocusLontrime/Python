# accepted on leetcode.com

RED = "\033[31m{}"
PURPLE = "\033[35m{}"
END = "\033[0m{}"


import math
import time
from collections import deque as deq

walk = ((1, 0), (0, -1), (-1, 0), (0, 1))

iters: int


def shortest_path(grid: list[list[int]], k: int) -> int:
    global iters
    iters = 0
    # linear sizes:
    max_j, max_i = len(grid), len(grid[0])
    # let us use 3 pars BFS:
    node = 0, 0, k, 0  # j, i, k_rem, path
    nodes_to_be_visited = deq([node])
    visited = [[[[math.inf, None] for _ in range(k + 1)] for _ in range(max_i)] for _ in range(max_j)]
    path_nodes = []
    while nodes_to_be_visited:
        # iteration:
        iters += 1
        # pop out the left node:
        j, i, k_, path = nodes_to_be_visited.popleft()
        # print(f'{j, i, k_, path = }')
        # print_grid(grid)
        # check for reaching the aim:
        if (j, i) == (max_j - 1, max_i - 1):
            print(f'{iters} iterations made...')
            # path's recovering:
            while True:
                _, node = visited[j][i][k_]
                # print(f'{j, i, k_ = }')
                path_nodes += [(j, i, k_)]
                if (j, i) == (0, 0):
                    break
                j, i, k_ = node
                # time.sleep(.2)
            print(f'{path_nodes = }')
            # let us change the grid a bit:
            for j, i, k_ in path_nodes:
                if grid[j][i] == 1:
                    grid[j][i] = 3
                elif grid[j][i] == 0:
                    grid[j][i] = 2
            print_grid(grid)
            return path
        # getting all the possible neighs:
        for dj, di in walk:
            j_, i_ = j + dj, i + di
            # we should stay within linear sizes bounds:
            if 0 <= j_ < max_j and 0 <= i_ < max_i:
                # if it is a wall node and k is still positive:
                if grid[j_][i_]:
                    if k_:
                        # if the node has not been visited:
                        if visited[j_][i_][k_ - 1][0] > path:
                            nodes_to_be_visited.append((j_, i_, k_ - 1, path + 1))
                            # visiting the node
                            visited[j_][i_][k_ - 1] = path, (j, i, k_)
                else:
                    # if the node has not been visited:
                    if visited[j_][i_][k_][0] > path:
                        # if it is a blank node:
                        nodes_to_be_visited.append((j_, i_, k_, path + 1))
                        # visiting the node
                        visited[j_][i_][k_] = path, (j, i, k_)
    print(f'{iters} iterations made...')
    return -1


def colour_(char, colour, flag=False):
    s = "\033[1m" if flag else ''
    return f"{(s + colour).format(char)}{END.format('')}"


def print_grid(grid: list[list[int]]):
    print(f'Solution demonstrating: ')
    print(f'{"_" * (len(grid[0]) + 2)}')
    for row in grid:
        print(f'|', end='')
        for cell in row:
            match cell:
                case 0:
                    print(f'.', end='')
                case 1:
                    print(f'{colour_("x", PURPLE)}', end='')
                case 2:
                    print(f'{colour_("*", RED)}', end='')
                case 3:
                    print(f'{colour_("x", RED)}', end='')
        print(f'|')
    print(f'{"_" * (len(grid[0]) + 2)}')


def bfs(j: int, i: int, max_j: int, max_i: int, k_rem: int, grid: list[list[int]]):
    ...


test_ex = [[0, 0, 0], [1, 1, 0], [0, 0, 0], [0, 1, 1], [0, 0, 0]], 1
test_ex_1 = [[0, 1, 1], [1, 1, 1], [1, 0, 0]], 1
test_ex_2 = [
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
], 5

test_ex_err = [
    [0,0],
    [1,0],
    [1,0],
    [1,0],
    [1,0],
    [1,0],
    [0,0],
    [0,1],
    [0,1],
    [0,1],
    [0,0],
    [1,0],
    [1,0],
    [0,0]
], 4

print(f'test ex res -> {shortest_path(*test_ex)}')                                    # 36 366 98 989 98989 LL LL
print(f'test ex 1 res -> {shortest_path(*test_ex_1)}')
print(f'test ex 2 res -> {shortest_path(*test_ex_2)}')
print(f'test ex err res -> {shortest_path(*test_ex_err)}')

print(f'{(9, 8) > (8, 7)}')
print(f'{(9, 8) > (9, 7)}')
print(f'{(9, 8) > (8, 10)}')
print(f'{(1, 1) > (1, 1)}')
print(f'{(1, 9) > (9, 1)}')

# print(f'LALA!')

print(f'res -> {colour_("fafa", RED)}')
